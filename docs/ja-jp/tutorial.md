
# チュートリアル
## 1. Siv3D の基本
### 1.1 インクルードするヘッダ

Siv3D のプログラムを書くときは、いつも `<Siv3D.hpp>` ヘッダをインクルードします。
```C++
# include <Siv3D.hpp>
```

これだけで、Siv3D のほぼすべての機能を使ってプログラムを書けるようになります。  
「ほぼ」というのは、マクロを定義することで利用可能になる上級者向けのいくつかの機能や、実験的な機能を提供するおまけのヘッダがあるためです。今はまだ説明しません。

C++ のプログラマなら、ほかにも `<iostream>` や `<vector>` などの C++ 標準ライブラリをインクルードしたくなるかもしれませんが、その必要はありません。すでに `<Siv3D.hpp>` の中で、Siv3D のプログラミングでよく使われる主要な C++ 標準ライブラリがインクルードされているためです。また、標準ライブラリの機能の多くが、より便利な Siv3D の関数やクラスで再実装されているので、Siv3D の学習の序盤で C++ 標準ライブラリの関数を使うことはめったにありません。

!!! 文法
    `# include <???>` または `# include "???"` で、ヘッダ `???` をインクルードします。前者の書き方では、標準ライブラリや、プロジェクトの設定でインクルードパスに設定されているフォルダのファイルが対象になり、後者では相対パスまたは絶対パスでファイルを検索します。Siv3D のプロジェクトでは、Siv3D のヘッダがあるディレクトリがインクルードパスに設定されていて、`# include <Siv3D.hpp>` で Siv3D のヘッダをインクルードできます。Siv3D 以外のプロジェクトで同じように書いても `Siv3D.hpp` を見つけられずコンパイルエラーになります。

### 1.2 エントリーポイント
通常、C++ のエントリーポイントは `int main()` です。しかし、Siv3D ではこの `main()` 関数は Siv3D エンジンによって実装されていて、次のようにユーザの見えないところで、ウィンドウやグラフィックスの初期化処理を行うプログラムがすでに用意されています。
```
// 説明のための疑似コード
int main()
{
    Siv3D の初期化...

    Main(); // この関数をユーザがプログラムする

    Siv3D の終了処理...
}
```
ユーザが実装するプログラムは、このプログラムの `void Main()` 関数です。

事前に初期化処理が完了しているので、`Main` 関数の中でいきなり Siv3D の機能を使うことができますし、`Main` 関数の実行が終了したら、ロードしたアセットやウィンドウの後片付けを Siv3D が自動的に行ってくれます。

### 1.3 最小のプログラム

ここまでの話を踏まえて、これが Siv3D の最小のプログラムです。
```C++
# include <Siv3D.hpp>

void Main()
{

}
```
ここでの `Main` 関数はすぐに終了してしまうので、このプログラムを実行しても、ほとんど何も反応が無いように見えるでしょう。

!!! 文法
    これは関数を定義するプログラムです。`Main` は関数の名前を、`void` はこの関数が結果の値を返さないことを表します。`{ }` 内には、この関数で実行したいプログラムを上から順に記述します。途中で `return` するか、終端までたどり着くと関数の実行は終了します。

### 1.4 メインループとウィンドウ

プログラムがすぐに終了してしまっては、ユーザとインタラクションするようなアプリケーションが作れません。`Main` 関数がずっと続くように **メインループ** を実装しましょう。次のプログラムを実行するとウィンドウが表示されます。
```C++ hl_lines="5 6 7 8"
# include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {

    }
}
```
新しく加えた行は `while` 文によってくり返し実行され、プログラムが半永久的に続くようになります。くり返しのたびに `System::Update` 関数がウィンドウの表示や音楽の再生、マウスやキーボードの入力情報などを更新するので、グラフィックスの表示やユーザとのやり取りをプログラムできるようになります。

!!! 文法
    `while()` 文は、`( )` 内の条件が真 (true) の間、`{ }` で囲まれた部分をくり返し実行します。

`System::Update` は普段は `true` を返しますが、ウィンドウが閉じられたり、エスケープキーが押されたりするなど、アプリケーションを終了させる特別な **ユーザアクション** が実行されると、以降はずっと `false` を返すようになります。 アプリケーションはこの状態になったら速やかにメインループから抜け、`Main` 関数を終了させる必要があります。といっても、上記のプログラムのように書いていれば、自然にこの通りに動作するので心配はありません。

!!! Info
    デフォルトでは「ウィンドウを閉じる」「エスケープキーを押す」「`System::Exit` 関数を呼ぶ」の 3 つが、アプリケーションを終了させるためのユーザアクションとして設定されています。この設定は`System::SetTerminationTriggers` 関数に `UserAction` フラグの組み合わせを渡すことでカスタマイズできます。

!!! Info
    メインループは、使用しているモニターのリフレッシュレートと同じ速度で繰り返されます（通常は毎秒 60, 120, または 144 フレーム）。`Graphics::SetTargetFrameRateHz` 関数に値を渡すことで、この上限を解除できます。

### 1.5 Hello, Siv3D!
画面にメッセージを表示してみましょう。Siv3D でテキストや数値を簡単に画面に表示するには、デバッグ表示のための機能 `Print` を使うと便利です。

```C++ hl_lines="5"
# include <Siv3D.hpp>

void Main()
{
	Print << U"Hello, Siv3D!";

	while (System::Update())
	{
		
	}
}
```
`Print` に向かって、出力の記号 `<<` でテキストを送ると、そのテキストが画面に表示されます。

![](images/tutorial/410.png)

!!! 文法
    テキストをプログラムに登場させるときは `" "` で囲みます。Siv3D ではさらに、日本語を扱いやすい UTF-32 という形式でテキストデータを扱うため、`"` の先頭には `U` というプレフィックスを付けます。

### 1.6 もっと Print
`Print` に送れるのは 1 つのテキストだけではありません。数値や配列、日付なども送ってみましょう。


```C++ hl_lines="7 8 9 10 11 12 13 14 15"
# include <Siv3D.hpp>

void Main()
{
	Print << U"Hello, Siv3D!";

    Print << U"This is fun!";

    Print << 365 << U" days";

    Print << 100 * 5 + 5;

    Print << Range(0, 10);

    Print << Date::Today();

	while (System::Update())
	{
		
	}
}
```

![](images/tutorial/510.png)

### 1.7 Print したものを消す
`Print` した内容は蓄積されるので、次のように `Print` をメインループの中で使うと、毎フレーム新しいメッセージが追加されて、古いメッセージを画面の外に追いやります。画面からあふれたメッセージは自動的に消えるので、`Print` のし過ぎを心配する必要はありません。

```C++
# include <Siv3D.hpp>

void Main()
{
	int32 count = 0;

	while (System::Update())
	{
		Print << count;

		++count;
	}
}
```

![](images/tutorial/610.png)

メッセージが画面外に消えるのを待たずに、プログラムを使って消去したいときには `ClearPrint` 関数を使います。プログラムのメインループの先頭で `ClearPrint` すると、その時点で蓄積されていたメッセージが全部消去され、つねに最新の `Print` した内容だけが表示されるようになります。

```C++ hl_lines="9"
# include <Siv3D.hpp>

void Main()
{
	int32 count = 0;

	while (System::Update())
	{
		ClearPrint(); // Print したメッセージを消去

		Print << count;

		++count;
	}
}
```

!!! Info
    Siv3D で整数を扱うときは、`int` や `unsigned long long` のような標準の型名の代わりに、`int32` や `uint64` のようにサイズを明示的に示した型名を使います。これらの型名を使うことで、プラットフォーム間での移植性が高まり、一貫性のある読みやすいコードになります。

### 1.8 画面の座標系

ウィンドウ内の黒い部分が **画面** で、Siv3D はこの領域に文字や図形、画像を表示できます。
画面のサイズは、基本の状態では **幅 800 ピクセル、高さ 600 ピクセル** です。画面上の位置を表す座標系は、一番左上のピクセルを「X 座標 0」「Y 座標 0」を表す `(0, 0)` と表記し、右に進むと X 座標が大きく、下に進むと Y 座標が大きくなります。画面の一番右下のピクセルの座標は `(799, 599)` です。 

`Cursor::Pos` 関数を使うと、現在のマウスカーソルの座標を `Point` 型で取得できます。`Point` 型の値は X 座標を表す `int32 x` と Y 座標を表す `int32 y` の 2 つの要素を持っていますが、そのまま丸ごと `Print` に送って表示することもできます。

```C++ hl_lines="9 10 11 12 13"
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		ClearPrint();

		Print << Cursor::Pos(); // 現在のマウスカーソル座標を表示

		Print << U"X: " << Cursor::Pos().x; // X 座標だけを表示

		Print << U"Y: " << Cursor::Pos().y; // Y 座標だけを表示
	}
}
```

![](images/tutorial/710.gif)

## 2. 図形を描く

### 2.1 円を描く
画面に図形を描く方法を学びましょう。Siv3D では、図形オブジェクトを作成し、その `draw()` メンバ関数を呼んで描画を行うのが基本的なやり方です。円を描くときは `Circle` を作成し、その `draw()` を呼びます。

```C++ hl_lines="8"
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		// 中心座標 (400, 300), 半径 20 の円を描く
		Circle(400, 300, 20).draw();
	}
}
```

![](images/tutorial/210.png)

`Circle()` の最後に指定するパラメータは円の半径です。この値を大きくすれば、描画される円も大きくなります。

```C++ hl_lines="8"
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		// 中心座標 (400, 300), 半径 100 の円を描く
		Circle(400, 300, 100).draw();
	}
}
```

![](images/tutorial/211.png)


円がマウスカーソルの座標に連動して動くようにしてみましょう。`Circle()` の最初に指定するパラメータは円の中心の X 座標です。この値をマウスカーソルの X 座標にしてみます。

```C++ hl_lines="7"
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		Circle(Cursor::Pos().x, 300, 100).draw();
	}
}
```

![](images/tutorial/212.gif)

マウスカーソルに追従して、円が左右に動くようになりました。

!!! Info
    `Print` で表示したメッセージはいつまでも画面に残りましたが、Siv3D では `Print` 以外のすべての描画内容は `System::Update` のたびに背景の色でリセットされます。

今度は Y 座標もマウスカーソルと連動するようにしてみます。

```C++ hl_lines="7"
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		Circle(Cursor::Pos().x, Cursor::Pos().y, 100).draw();
	}
}
```

![](images/tutorial/213.gif)

Siv3D で X 座標、Y 座標 2 つの値を受け取る関数は、多くの場合、1 つの Point 型を受け取る別バージョンの関数（オーバーロード）を提供しているケースがよくあります。`Circle` も、「X 座標」「Y 座標」「半径」の 3 つの引数ではなく、「中心座標 (`Point` 型)」「半径」の 2 つの引数を受け取るオーバーロードがあります。これを使うと、先ほど同じはたらきをするコードを短く書けます。

```C++ hl_lines="7"
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		Circle(Cursor::Pos(), 100).draw();
	}
}
```

### 2.2 色を付ける
図形に色を付けたいときは `draw()` 関数に色を渡します。色の指定の方法は大きく 4 通りあります。

| 色の表現               | 値の範囲                                                                                                  |
|--------------------|-------------------------------------------------------------------------------------------------------|
| Palette::色名        | [Web カラー :fa-external-link:](https://ironodata.info/colorscheme/colorname.html) の名前で色を指定                                                                                       |
| ColorF(r, g, b, a) | 0.0 - 1.0 の範囲で RGBA の各成分を指定                                                                           |
| Color(r, g, b, a)  | 0 - 255 の整数の範囲で RGBA の各成分を指定                                                                          |
| HSV(h, s, v, a)    | 色相 `h`, 彩度 `s`, 明度 `v` とアルファ値 `a` の各成分を指定。<br>h は 0.0 - 360.0 (370.0 は 10.0 と同じ). s, v, a は 0.0 - 1.0,の範囲 |

**Palette::色名** は RGB 値を覚えていなくても使える色の表現です。

**ColorF** は Siv3D で一番使い勝手が良い色の表現形式です。

**Color** は `Image` 型の要素で、Siv3D で画像処理をするときに使われる形式です。

**HSV** は赤っぽい、青っぽいなど色の種類を表す色相 (hue) と、色の鮮やかを表す彩度 (saturation), 色の明るさを表す明度 (value) の 3 要素を使った HSV 色空間で色を表現します。

`ColorF`, `Color`, `HSV` はいずれも **アルファ値** `a` を持ちます。アルファ値は「不透明度」を表し、最大値 (`ColorF`, `HSV` の場合 1.0, `Color` の場合 255) ではまったく透過しませんが、値を小さくするとそれに応じて背景を透過する半透明になり、0 になると完全に透明になります。

色の指定はプログラムでよく使われるので、次のような短い書き方も用意されています。例えば `ColorF(0.5)` は `ColorF(0.5, 0.5, 0.5, 1.0)` と同等です。

| 短い書き方           | 意味                         |
|-----------------|----------------------------|
| `ColorF(r, g, b)` | `ColorF(r, g, b, 1.0)`       |
| `ColorF(rgb, a)`  | `ColorF(rgb, rgb, rgb, a)`   |
| `ColorF(rgb)`     | `ColorF(rgb, rgb, rgb, 1.0)` |
| `Color(r, g, b)`  | `Color(r, g, b, 255)`        |
| `Color(rgb, a)`   | `Color(rgb, rgb, rgb, a)`    |
| `Color(rgb)`      | `Color(rgb, rgb, rgb, 255)`  |
| `HSV(h, s, v)`    | `HSV(h, s, v, 1.0)`          |
| `HSV(h, a)`       | `HSV(h, 1.0, 1.0, a)`        |
| `HSV(h)`          | `HSV(h, 1.0, 1.0, 1.0)`      |

色の付いたいくつかの円を描いてみましょう。`draw()` に色を指定しなかった場合の図形の色は `Palette::White` (`ColorF(1.0, 1.0, 1.0, 1.0)`) になります。

```C++
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		// 左から順に 7 つの円を描く
		Circle(100, 200, 40).draw();

		Circle(200, 200, 40).draw(Palette::Green);

		Circle(300, 200, 40).draw(Palette::Skyblue);

		Circle(400, 200, 40).draw(ColorF(1.0, 0.8, 0.0));

		Circle(500, 200, 40).draw(Color(255, 127, 127));

		Circle(600, 200, 40).draw(HSV(160.0, 1.0, 1.0));

		Circle(700, 200, 40).draw(HSV(160.0, 0.75, 1.0));

		// 半透明の円
		Circle(Cursor::Pos(), 80).draw(ColorF(0.0, 0.5, 1.0, 0.8));
	}
}
```

![](images/tutorial/220.gif)


### 2.3 背景の色を変える
背景の色を変えるには `Scene::SetBackground` 関数に色を渡します。新しい背景色は、次の `System::Update` で画面の描画内容をリセットするときから反映されます。背景色は一度設定すると、再度変更されるまで同じ設定が使われます。

```C++ hl_lines="5"
# include <Siv3D.hpp>

void Main()
{
	Scene::SetBackground(ColorF(0.3, 0.6, 1.0));

	while (System::Update())
	{
		Circle(Cursor::Pos(), 80).draw();
	}
}
```

![](images/tutorial/230.gif)

背景色の変更にコストはかからないので、背景色は毎フレーム変更しても大丈夫です。プログラムの経過時間（秒）を `Scene::Time` で取得して、時間に応じて背景色の色相を変化させてみましょう。

```C++
# include <Siv3D.hpp>

void Main()
{
	while (System::Update())
	{
		const double hue = Scene::Time() * 60.0;

		Scene::SetBackground(HSV(hue, 0.6, 1.0));
	}
}
```

![](images/tutorial/231.gif)

### 2.4 長方形を描く
長方形を描くときは `Rect` を作成し、その `draw()` を呼びます。
